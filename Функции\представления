-- 1. Функция для чтения счёта (автоматически сохраняет xmin!)
CREATE OR REPLACE FUNCTION get_account(p_id int)
RETURNS TABLE(id int, holder text, balance numeric(8,2))
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT a.id, a.holder, a.balance
    FROM bank_accounts a
    WHERE a.id = p_id;

    -- Эта строка выполнится ТОЛЬКО если предыдущий запрос нашёл хотя бы одну строку
    IF FOUND THEN
        PERFORM set_config('myapp.xmin_' || p_id, a.xmin::text, true)
        FROM bank_accounts a
        WHERE a.id = p_id;
    END IF;
END;
$$;


-- 2. Триггерная функция для предотвращения Update Lost
CREATE OR REPLACE FUNCTION prevent_lost_update()
RETURNS trigger AS $$
DECLARE
    saved_xmin xid := current_setting('myapp.xmin_' || NEW.id, true)::xid;
	current_xmin xid;
BEGIN
	SELECT xmin INTO current_xmin
    FROM bank_accounts
    WHERE id = NEW.id;
    -- Ключевое сравнение: версия при чтении ≠ текущая версия строки
    IF saved_xmin IS NOT NULL AND saved_xmin <> current_xmin THEN
        -- Логируем конфликт
		INSERT INTO conflict_log (
            operation, table_name, conflict_type,
            old_balance, new_balance, message
        ) VALUES (
            TG_OP,
            TG_TABLE_NAME,
            'LOST_UPDATE',
            OLD.balance,
            NEW.balance,
            format('Lost Update на счёте id=%s: ожидался xmin=%s, текущий xmin=%s',
                   NEW.id, saved_xmin, current_xmin)
        );

		-- выброс ошибки
        RETURN NULL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION guarded_query_accounts(condition text)
RETURNS SETOF bank_accounts AS $$
DECLARE
    lock_key bigint := hashtext('bank_accounts');
    lock_ok boolean;
    full_query text;
BEGIN
    lock_ok := pg_try_advisory_xact_lock_shared(lock_key);

    IF NOT lock_ok THEN
        INSERT INTO conflict_log(
            operation, table_name, conflict_type, message
        ) VALUES (
            'SELECT', 'bank_accounts', 'TRY_LOCK_FAILURE_ON_SELECT',
            'Попытка блокировки не удалась: источник занят'
        );
        RETURN;
    END IF;

    full_query := format('SELECT * FROM bank_accounts WHERE %s', condition);
    RETURN QUERY EXECUTE full_query;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION accounts_guarded_write()
RETURNS TRIGGER AS $$
DECLARE
    lock_key bigint := hashtext('bank_accounts');  -- уникальный ключ для advisory lock
    lock_ok boolean;
BEGIN
    -- пытаемся взять блокировку на уровне транзакции
    lock_ok := pg_try_advisory_xact_lock(lock_key);

    IF NOT lock_ok THEN
        -- другой процесс держит lock, логируем конфликт
        INSERT INTO conflict_log(
            operation, table_name, conflict_type, message,
            old_balance, new_balance
        ) VALUES (
            TG_OP,
            TG_TABLE_NAME,
            'TRY_LOCK_FAILURE',
            format(
                'Не удалось выполнить %s в таблице %s: advisory lock %s уже занят другой транзакцией',
                TG_OP,
                TG_TABLE_NAME,
                lock_key
            ),
            OLD.balance,
            NEW.balance
        );

        RETURN NULL;
    END IF;

    -- lock получен, продолжаем операцию
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION accounts_business_rule_check()
RETURNS TRIGGER AS $$
DECLARE
    cnt_active int;
BEGIN
    SELECT COUNT(*) INTO cnt_active FROM bank_accounts WHERE is_active = TRUE;

    IF cnt_active <= 1 THEN
        RAISE EXCEPTION
            'Нарушено бизнес-правило: должна оставаться хотя бы одна активная учетная запись.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
