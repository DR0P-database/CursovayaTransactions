-- 1. Функция для чтения счёта (автоматически сохраняет xmin!)
CREATE OR REPLACE FUNCTION get_account(p_id int)
RETURNS TABLE(id int, holder text, balance numeric(8,2))
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT a.id, a.holder, a.balance
    FROM bank_accounts a
    WHERE a.id = p_id;

    -- Эта строка выполнится ТОЛЬКО если предыдущий запрос нашёл хотя бы одну строку
    IF FOUND THEN
        PERFORM set_config('myapp.xmin_' || p_id, a.xmin::text, true)
        FROM bank_accounts a
        WHERE a.id = p_id;
    END IF;
END;
$$;


-- 2. Триггерная функция для предотвращения Update Lost
CREATE OR REPLACE FUNCTION prevent_lost_update()
RETURNS trigger AS $$
DECLARE
    saved_xmin xid := current_setting('myapp.xmin_' || NEW.id, true)::xid;
	current_xmin xid;
BEGIN
	SELECT xmin INTO current_xmin
    FROM bank_accounts
    WHERE id = NEW.id;
    -- Ключевое сравнение: версия при чтении ≠ текущая версия строки
    IF saved_xmin IS NOT NULL AND saved_xmin <> current_xmin THEN
        -- Логируем конфликт
		INSERT INTO conflict_log (
            operation, table_name, conflict_type,
            old_balance, new_balance, message
        ) VALUES (
            TG_OP,
            TG_TABLE_NAME,
            'LOST_UPDATE',
            OLD.balance,
            NEW.balance,
            format('Lost Update на счёте id=%s: ожидался xmin=%s, текущий xmin=%s',
                   NEW.id, saved_xmin, current_xmin)
        );

		-- выброс ошибки
        RETURN NULL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--================ Функция для любых SELECT  с блокировкой доступа к CUD ================--
CREATE OR REPLACE FUNCTION guarded_query(q text)
RETURNS SETOF jsonb AS $$
BEGIN
    -- Блокируем только нужные таблицы по целому слову
    IF q ~ '\ybank_accounts\y' THEN
        PERFORM pg_advisory_xact_lock_shared(hashtext('bank_accounts'));
    END IF;
	-- Возвращаем запрос с блокировкой
    RETURN QUERY EXECUTE
        format('SELECT to_jsonb(t) FROM (%s) AS t', q);
END;
$$ LANGUAGE plpgsql;

-- Триггер функция для предотвращения Non-repeatable Read и Phantom Read
CREATE OR REPLACE FUNCTION guarded_write()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT pg_try_advisory_xact_lock(hashtext(TG_TABLE_NAME)) THEN
	INSERT INTO conflict_log (operation, table_name, conflict_type, message)
        VALUES (
            TG_OP,
            TG_TABLE_NAME,
            'Read-Write-Read',
            format('Заблокирована операция %s над таблицей %s из-за временного отсутствия доступа', TG_OP, TG_TABLE_NAME)
        );
		RETURN NULL;
    END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер функция для предотвращения Anomaly / Write Skew 
CREATE OR REPLACE FUNCTION trg_lock_doctors_active_status()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status = true AND NEW.status = false THEN

        -- 1. Пытаемся захватить эксклюзивный lock на инвариант
        IF NOT pg_try_advisory_xact_lock(hashtext('doctors:status:active')) THEN
            INSERT INTO conflict_log (operation, table_name, conflict_type, message)
            VALUES (
                TG_OP,
                TG_TABLE_NAME,
                'Write Skew',
                'Попытка одновременно деактивировать последнего активного врача — отклонено'
            );
            RETURN NULL;  -- строка не обновляется
        END IF;

        -- 2. Теперь под защитой проверяем актуальное количество
        IF (SELECT COUNT(*) FROM doctors WHERE status = true) <= 1 THEN
            RAISE EXCEPTION 'Нельзя деактивировать последнего активного врача';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
